import heapq
edges = [(1, 2, 3), (1, 3 ,4), (1, 4, 2), (2, 6, 3), (3, 6, 6), (4, 6, 2), (4, 5, 5), (5,7,6),(5,9,12),(6,5,1),(6,7,8),(6,8,7),(7,10,4),(8,10,3),(9,8,6),(9,10,11)]
graph = {
    "1": {"2": 3, "3": 4, "4": 2},
    "2": {"6": 3},
    "3": {"6": 6},
    "4": {"6": 2, "5": 5},
    "5": {"7": 6, "9": 12},
    "6": {"5": 1, "7": 8, "8": 7},
    "7": {"10": 4},
    "8": {"10": 3},
    "9": {"8": 9, "10": 11},
    "10":{}
}


def shortest_path(graph : dict, start : int, end: int):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    queue = [(0, start)]
    while queue:
        now_distance, current_vertex = heapq.heappop(queue)
        if now_distance > distances[current_vertex]:
            continue
        for neighbor, weight in graph[str(current_vertex)].items():
            rast = now_distance + weight
            if rast < distances[neighbor]:
                distances[neighbor] = rast
                heapq.heappush(queue, (rast, neighbor))
    finish = f"Оптимальный путь - {distances[str(end)]}"
    return finish

print(shortest_path(graph,1,10))
